#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
YUPS - Core Executable (v8 - Client/Server Edition)

Changes:
- REMOVED: Direct dependency on 'huggingface_hub.InferenceClient'.
- ADDED: Logic to call our custom YUPS API (yups-server).
- CONFIG: Now requires YUPS_API_URL pointing to the VPS.
- CLEANUP: Simplified auth (no HF_TOKEN needed on client).
"""

import sys
import os
import platform
import datetime
import json
import shutil
import shlex
import subprocess
import argparse
import threading
import requests # We rely on requests now (installed via venv)

# --- Configuration ---
YUPS_API_URL = "https://yups.io" 
YUPS_CLIENT_SECRET = "yups-secret-v1-camaleon"

YUPS_DIR = os.path.expanduser("~/.yups")
CONFIG_FILE = os.path.join(YUPS_DIR, "config.json")
LOG_DIR = os.path.join(YUPS_DIR, "logs")

LOG_FILES = {
    "cnf": os.path.join(LOG_DIR, "cnf.log"),
    "ce": os.path.join(LOG_DIR, "ce.log"),
    "query": os.path.join(LOG_DIR, "query.log"),
    "action": os.path.join(LOG_DIR, "action.log")
}

KNOWN_PMS = ["apt", "apt-get", "dnf", "yum", "pacman", "zypper"]

# --- PM Abstraction Matrix ---
PM_COMMANDS = {
    "install": {
        "help": "Install one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt install {packages}",
            "dnf": "sudo dnf install {packages}",
            "pacman": "sudo pacman -S {packages}",
            "zypper": "sudo zypper install {packages}",
        }
    },
    "remove": {
        "help": "Remove one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt remove {packages}",
            "dnf": "sudo dnf remove {packages}",
            "pacman": "sudo pacman -R {packages}",
            "zypper": "sudo zypper remove {packages}",
        }
    },
    "search": {
        "help": "Search for available packages.",
        "takes_packages": True,
        "commands": {
            "apt": "apt search {packages}",
            "dnf": "dnf search {packages}",
            "pacman": "pacman -Ss {packages}",
            "zypper": "zypper search {packages}",
        }
    },
    "autoremove": {
        "help": "Remove unused packages (cleanup).",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt autoremove",
            "dnf": "sudo dnf autoremove",
            "pacman": "sudo pacman -Rns $(pacman -Qdtq)",
            "zypper": "sudo zypper remove --clean-deps",
        }
    },
    "upgrade": {
        "help": "Upgrade all installed packages.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt upgrade",
            "dnf": "sudo dnf upgrade",
            "pacman": "sudo pacman -Syu",
            "zypper": "sudo zypper dup",
        }
    },
    "update": {
        "help": "Refresh package repository information.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt update",
            "dnf": "sudo dnf check-update",
            "pacman": "sudo pacman -Sy",
            "zypper": "sudo zypper refresh",
        }
    },
    "provides": {
        "help": "Find which package provides a file or command.",
        "takes_packages": True,
        "commands": {
            "apt": "echo 'Use: apt-file search {packages} (requires apt-file)'",
            "dnf": "dnf provides {packages}",
            "pacman": "echo 'Use: pacman -F {packages} (requires pkgfile)'",
            "zypper": "zypper what-provides {packages}",
        }
    }
}
PM_ALIASES = {
    "add": "install",
    "+": "install",
    "-": "remove",
    "uninstall": "remove",
    "delete": "remove",
    "del": "remove",
    "available": "search",
    "find": "search",
    "clean": "autoremove",
    "upgrade-all": "upgrade",
    "upgradeall": "upgrade",
    "updaterepos": "update",
    "update-repos": "update",
    "what-provides": "provides",
    "where": "provides",
    "where-is": "provides",
    "whereis": "provides",
    "which": "provides",
}

# --- 1. Asynchronous Logging ---

def _log_to_file_sync(log_file, message):
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
        timestamp = datetime.datetime.now().isoformat()
        log_entry = f"{timestamp} | {message}\n"
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    except Exception:
        pass

def log_async(log_type, message):
    log_file = LOG_FILES.get(log_type)
    if not log_file:
        return
    log_thread = threading.Thread(
        target=_log_to_file_sync,
        args=(log_file, message),
        daemon=True
    )
    log_thread.start()

# --- 2. Config and Detection Logic ---

def detect_os_details():
    os_name = platform.system()
    distro_info = {
        "id": "unknown",
        "version_id": "unknown",
        "pretty_name": f"{os_name} (Unknown Distro)"
    }
    if os_name == "Linux" and os.path.exists("/etc/os-release"):
        try:
            with open("/etc/os-release", 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if '=' in line:
                        key, value = line.split('=', 1)
                        value = value.strip('"')
                        if key == "ID":
                            distro_info["id"] = value
                        elif key == "VERSION_ID":
                            distro_info["version_id"] = value
                        elif key == "PRETTY_NAME":
                            distro_info["pretty_name"] = value
        except Exception:
            pass
    return os_name, distro_info

def detect_pm():
    for pm_name in KNOWN_PMS:
        if shutil.which(pm_name):
            if pm_name == "apt-get":
                return "apt"
            if pm_name == "yum":
                if shutil.which("dnf"):
                    return "dnf"
                return "yum"
            return pm_name
    return "unknown"

def run_auto_config():
    os.makedirs(YUPS_DIR, exist_ok=True)
    os_name, distro_info = detect_os_details()
    pm_name = detect_pm()
    config = {
        "os": os_name,
        "pm": pm_name,
        "distro_id": distro_info.get("id"),
        "distro_version": distro_info.get("version_id"),
        "distro_pretty": distro_info.get("pretty_name"),
    }
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
        print(f"YUPS: Configuration saved to {CONFIG_FILE}")
        return config
    except Exception as e:
        print(f"YUPS_ERROR: Could not write config file: {e}", file=sys.stderr)
        return config

def get_config_cache():
    if not os.path.exists(CONFIG_FILE):
        return run_auto_config()
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return run_auto_config()

# --- 3. Handler Logic ---

def handle_cnf(args):
    log_async("cnf", f"raw_args: {args}")
    if not args:
        return 127
    
    failed_cmd = args[0]
    failed_args = args[1:]
    config = get_config_cache()
    host_pm = config.get("pm")

    if failed_cmd in KNOWN_PMS:
        if failed_cmd != host_pm and host_pm != "unknown":
            log_async("cnf", f"PM mismatch. Found: {failed_cmd}, Host: {host_pm}")
            print(f"YUPS: Command '{failed_cmd}' not found.", file=sys.stderr)
            print(f"YUPS: Maybe you meant '{host_pm}'?", file=sys.stderr)
            print(f"YUPS: Try 'yups {failed_cmd} {' '.join(failed_args)}'", file=sys.stderr)
            return 126
    
    default_handlers = [
        "/usr/libexec/packagekit-command-not-found",
        "/usr/libexec/pk-command-not-found",
        "/usr/lib/command-not-found",
        "/usr/share/command-not-found/command-not-found"
    ]
    for handler in default_handlers:
        if os.path.exists(handler):
            try:
                result = subprocess.run([handler] + args, check=False)
                return result.returncode
            except Exception:
                pass
                
    return 127

def handle_ce(args):
    if len(args) != 2:
        return
    
    exit_code_str, last_command = args[0], args[1]
    log_async("ce", f"exit_code: {exit_code_str}, cmd: '{last_command}'")
    
    command_with_padding = f" {last_command} "
    found_pm_in_cmd = False
    for pm in KNOWN_PMS:
        if f" {pm} " in command_with_padding:
            found_pm_in_cmd = True
            break

    if found_pm_in_cmd:
        print(f"---", file=sys.stderr)
        print(f"YUPS: The command '{last_command.strip()}' failed (Code: {exit_code_str}).", file=sys.stderr)
        if ' instal ' in last_command:
            print(f"YUPS: Did you mean 'install'?", file=sys.stderr)
        elif ' delete ' in last_command:
            print(f"YUPS: Did you mean 'remove' or 'autoremove'?", file=sys.stderr)
        print(f"YUPS: Try 'yups {last_command.strip()}'", file=sys.stderr)
        print(f"---", file=sys.stderr)

def handle_pm_command(action, packages, config):
    host_pm = config.get("pm")
    if host_pm == "unknown":
        print(f"YUPS_ERROR: Could not detect a known package manager.", file=sys.stderr)
        return
        
    action = PM_ALIASES.get(action, action)

    if action not in PM_COMMANDS:
        print(f"YUPS_ERROR: Unknown action '{action}'.", file=sys.stderr)
        return

    pm_config = PM_COMMANDS[action]
    command_template = pm_config["commands"].get(host_pm)
    
    if not command_template:
        print(f"YUPS_ERROR: Action '{action}' is not supported for '{host_pm}'.", file=sys.stderr)
        return
        
    package_string = " ".join(packages)

    if not pm_config["takes_packages"] and packages:
        print(f"YUPS_WARN: Action '{action}' does not take package arguments. Ignoring '{package_string}'.")
        package_string = ""
            
    if pm_config["takes_packages"] and not packages:
         print(f"YUPS_ERROR: Action '{action}' requires one or more package names.", file=sys.stderr)
         print(f"Example: yups {action} <package_name>")
         return

    final_command = command_template.format(packages=package_string)
    
    # Simple sudo removal if running as root
    if os.geteuid() == 0 and final_command.startswith("sudo "):
        final_command = final_command.replace("sudo ", "", 1)

    log_async("action", f"user: 'yups {action} {package_string}', host_pm: {host_pm}, exec: '{final_command}'")
    
    print(f"YUPS: Detected {host_pm}. Running:")
    print(f"+ {final_command}\n")
    
    subprocess.run(final_command, shell=True, check=False)

# --- 4. API & Intelligence Layer (Server-Side) ---

def fetch_llm_suggestion( query, config):
    """
    Calls the YUPS API Server.
    Authentication is done via Client Secret Header, no user token needed.
    """
    # Construct endpoint URL
    endpoint = f"{YUPS_API_URL}/yups/v1/chat"
    
    headers = {
        "Content-Type": "application/json",
        "X-Yups-Client-Auth": YUPS_CLIENT_SECRET
    }

    payload = {
        "query": query,
        "config": config  
    }
    
    try:
        # Using a timeout to prevent hanging if server is down
        response = requests.post(endpoint, data=json.dumps(payload), headers=headers, timeout=30)
        
        if response.status_code == 429:
            return {"error": "You are sending requests too fast. Please wait."}
        
        if not response.ok:
            return {"error": f"Server Error ({response.status_code}): {response.text}"}
            
        data = response.json()
        
        # The server returns { "result": {...}, "meta": {...} }
        # We only care about "result"
        return data.get("result", {"error": "Empty response from server"})

    except requests.exceptions.ConnectionError:
        return {"error": "Could not connect to YUPS Server. Check your internet connection."}
    except requests.exceptions.Timeout:
        return {"error": "YUPS Server timed out."}
    except Exception as e:
        return {"error": f"Client Error: {str(e)}"}

# --- 5. Main Argument Parsing & Routing ---

def build_help_epilog():
    pm_help = "\nPackage Manager Commands:\n"
    for action, config in PM_COMMANDS.items():
        pm_help += f"  {action:<12} {config['help']}\n"
        
    alias_help = "\nCommand Aliases:\n"
    inverted_aliases = {}
    for alias, target in PM_ALIASES.items():
        inverted_aliases.setdefault(target, []).append(alias)
        
    for target, aliases in inverted_aliases.items():
        alias_help += f"  ({', '.join(aliases)}) -> {target}\n"
        
    final_epilog = (
        f"{pm_help}"
        f"{alias_help}\n"
        "If no specific command is given, 'yups' logs your query."
    )
    return final_epilog

def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == '--cnf-handle':
            args = sys.argv[2:]
            exit_code = handle_cnf(args)
            sys.exit(exit_code)
            
        if sys.argv[1] == '--ce-handle':
            args = sys.argv[2:]
            handle_ce(args)
            sys.exit(0)
    
    help_epilog = build_help_epilog()
    
    parser = argparse.ArgumentParser(
        description="YUPS: A Shell Helper and Package Manager wrapper.",
        epilog=help_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False
    )
    
    parser.add_argument('-h', '--help', action='store_true', help="show this help message and exit")
    parser.add_argument('--auto-config', action='store_true', help="Regenerate the system configuration cache.")
    
    args, remaining_args = parser.parse_known_args()
    
    if args.help:
        parser.print_help()
        sys.exit(0)
        
    if args.auto_config:
        run_auto_config()
        sys.exit(0)
        
    config = get_config_cache()
    
    if not remaining_args:
        parser.print_help()
        sys.exit(0)

    action = remaining_args[0].lower()
    packages = remaining_args[1:]
    
    if action in PM_COMMANDS or action in PM_ALIASES:
        handle_pm_command(action, packages, config)
        
    else:
        # --- Fallback: Smart action ---
        query_string = " ".join(remaining_args)
        
        # 1. Update Context
        config['is_root'] = (os.geteuid() == 0)

        # 2. Call the API Layer
        print("☁️  Asking YUPS Cloud...")
        parsed = fetch_llm_suggestion(query_string,config)
        
        # 3. Handle Errors/Feedback
        if parsed.get("error"):
            print(f"YUPS_ERROR: {parsed['error']}", file=sys.stderr)
        
        if parsed.get("explanation"):
            print(f"YUPS: {parsed['explanation']}")
            
        cmd = parsed.get("command")
        if cmd and cmd != "error":
            
            # --- Safety Guard ---
            if config['is_root'] and cmd.strip().startswith("sudo "):
                 cmd = cmd.strip().replace("sudo ", "", 1)

            print(f"Suggested command: {cmd}")
            try:
                confirm = input("Execute this command? [y/N] ").strip().lower()
                if confirm == 'y':
                    subprocess.run(cmd, shell=True, check=False)
                else:
                    print("Aborted.")
            except EOFError:
                pass
        else:
             if not parsed.get("error"):
                 print("YUPS_ERROR: No command suggested.", file=sys.stderr)

        log_async("query", f"{query_string} -> {json.dumps(parsed)}")

if __name__ == "__main__":
    main()