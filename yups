#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
YUPS - Core Executable (v11 - Fast Provides Edition)

Changes:
- OPTIMIZED: 'provides' commands now use real tools (apt-file, pkgfile) instead of echo.
- OPTIMIZED: Added '-C' (dnf) and '--no-refresh' (zypper) for faster lookups.
- CONFIG: YUPS_API_URL points to the production server.
"""

import sys
import os
import platform
import datetime
import json
import shutil
import shlex
import subprocess
import argparse
import threading
import requests

# --- Configuration ---
YUPS_API_URL = "https://yups.io" 
YUPS_CLIENT_HEADER_NAME = "X-Yups-Client-Auth"
YUPS_CLIENT_SECRET = "yups-secret-v1-camaleon"

YUPS_DIR = os.path.expanduser("~/.yups")
CONFIG_FILE = os.path.join(YUPS_DIR, "config.json")
LOG_DIR = os.path.join(YUPS_DIR, "logs")

LOG_FILES = {
    "cnf": os.path.join(LOG_DIR, "cnf.log"),
    "ce": os.path.join(LOG_DIR, "ce.log"),
    "query": os.path.join(LOG_DIR, "query.log"),
    "action": os.path.join(LOG_DIR, "action.log")
}

KNOWN_PMS = ["apt", "apt-get", "dnf", "yum", "pacman", "zypper"]

# --- PM Abstraction Matrix (Standard Commands) ---
PM_COMMANDS = {
    "install": {
        "help": "Install one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt install {packages}",
            "dnf": "sudo dnf install {packages}",
            "pacman": "sudo pacman -S {packages}",
            "zypper": "sudo zypper install {packages}",
        }
    },
    "remove": {
        "help": "Remove one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt remove {packages}",
            "dnf": "sudo dnf remove {packages}",
            "pacman": "sudo pacman -R {packages}",
            "zypper": "sudo zypper remove {packages}",
        }
    },
    "search": {
        "help": "Search for available packages.",
        "takes_packages": True,
        "commands": {
            "apt": "apt search {packages}",
            # Optimization: -C for dnf (cache only)
            "dnf": "dnf search -C {packages}", 
            "pacman": "pacman -Ss {packages}",
            # Optimization: --no-refresh for zypper
            "zypper": "zypper --no-refresh search {packages}", 
        }
    },
    "autoremove": {
        "help": "Remove unused packages (cleanup).",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt autoremove",
            "dnf": "sudo dnf autoremove",
            "pacman": "sudo pacman -Rns $(pacman -Qdtq)",
            "zypper": "sudo zypper remove --clean-deps",
        }
    },
    "upgrade": {
        "help": "Upgrade all installed packages.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt upgrade",
            "dnf": "sudo dnf upgrade",
            "pacman": "sudo pacman -Syu",
            "zypper": "sudo zypper dup",
        }
    },
    "update": {
        "help": "Refresh package repository information.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt update",
            "dnf": "sudo dnf check-update",
            "pacman": "sudo pacman -Sy",
            "zypper": "sudo zypper refresh",
        }
    },
    "provides": {
        "help": "Find which package provides a file or command.",
        "takes_packages": True,
        "commands": {
            # Now using real commands thanks to install.sh helpers
            "apt": "apt-file search {packages}", 
            "dnf": "dnf provides -C {packages}",
            "pacman": "pacman -F {packages}",
            "zypper": "zypper --no-refresh what-provides {packages}",
        }
    }
}

# Special Handlers not in the matrix
EXTRA_COMMANDS = ["export", "import"]

PM_ALIASES = {
    "add": "install",
    "+": "install",
    "-": "remove",
    "uninstall": "remove",
    "delete": "remove",
    "del": "remove",
    "available": "search",
    "find": "search",
    "clean": "autoremove",
    "upgrade-all": "upgrade",
    "upgradeall": "upgrade",
    "updaterepos": "update",
    "update-repos": "update",
    "what-provides": "provides",
    "where": "provides",
    "where-is": "provides",
    "whereis": "provides",
    "which": "provides",
    "backup": "export",
    "restore": "import"
}

# --- 1. Asynchronous Logging ---

def _log_to_file_sync(log_file, message):
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
        timestamp = datetime.datetime.now().isoformat()
        log_entry = f"{timestamp} | {message}\n"
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    except Exception:
        pass

def log_async(log_type, message):
    log_file = LOG_FILES.get(log_type)
    if not log_file:
        return
    log_thread = threading.Thread(
        target=_log_to_file_sync,
        args=(log_file, message),
        daemon=True
    )
    log_thread.start()

# --- 2. Config and Detection Logic ---

def detect_os_details():
    os_name = platform.system()
    distro_info = {
        "id": "unknown",
        "version_id": "unknown",
        "pretty_name": f"{os_name} (Unknown Distro)"
    }
    if os_name == "Linux" and os.path.exists("/etc/os-release"):
        try:
            with open("/etc/os-release", 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if '=' in line:
                        key, value = line.split('=', 1)
                        value = value.strip('"')
                        if key == "ID":
                            distro_info["id"] = value
                        elif key == "VERSION_ID":
                            distro_info["version_id"] = value
                        elif key == "PRETTY_NAME":
                            distro_info["pretty_name"] = value
        except Exception:
            pass
    return os_name, distro_info

def detect_pm():
    for pm_name in KNOWN_PMS:
        if shutil.which(pm_name):
            if pm_name == "apt-get":
                return "apt"
            if pm_name == "yum":
                if shutil.which("dnf"):
                    return "dnf"
                return "yum"
            return pm_name
    return "unknown"

def run_auto_config():
    os.makedirs(YUPS_DIR, exist_ok=True)
    os_name, distro_info = detect_os_details()
    pm_name = detect_pm()
    config = {
        "os": os_name,
        "pm": pm_name,
        "distro_id": distro_info.get("id"),
        "distro_version": distro_info.get("version_id"),
        "distro_pretty": distro_info.get("pretty_name"),
    }
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
        return config
    except Exception as e:
        print(f"YUPS_ERROR: Could not write config file: {e}", file=sys.stderr)
        return config

def get_config_cache():
    if not os.path.exists(CONFIG_FILE):
        return run_auto_config()
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return run_auto_config()

# --- 3. Handler Logic (Hooks) ---

def handle_cnf(args):
    log_async("cnf", f"raw_args: {args}")
    if not args:
        return 127
    
    failed_cmd = args[0]
    failed_args = args[1:]
    config = get_config_cache()
    host_pm = config.get("pm")

    if failed_cmd in KNOWN_PMS:
        if failed_cmd != host_pm and host_pm != "unknown":
            log_async("cnf", f"PM mismatch. Found: {failed_cmd}, Host: {host_pm}")
            print(f"YUPS: Command '{failed_cmd}' not found.", file=sys.stderr)
            print(f"YUPS: Maybe you meant '{host_pm}'?", file=sys.stderr)
            print(f"YUPS: Try 'yups {failed_cmd} {' '.join(failed_args)}'", file=sys.stderr)
            return 126
    
    default_handlers = [
        "/usr/libexec/packagekit-command-not-found",
        "/usr/libexec/pk-command-not-found",
        "/usr/lib/command-not-found",
        "/usr/share/command-not-found/command-not-found"
    ]
    for handler in default_handlers:
        if os.path.exists(handler):
            try:
                result = subprocess.run([handler] + args, check=False)
                return result.returncode
            except Exception:
                pass
                
    return 127

def handle_ce(args):
    if len(args) != 2:
        return
    
    exit_code_str, last_command = args[0], args[1]
    log_async("ce", f"exit_code: {exit_code_str}, cmd: '{last_command}'")
    
    command_with_padding = f" {last_command} "
    found_pm_in_cmd = False
    for pm in KNOWN_PMS:
        if f" {pm} " in command_with_padding:
            found_pm_in_cmd = True
            break

    if found_pm_in_cmd:
        print(f"---", file=sys.stderr)
        print(f"YUPS: The command '{last_command.strip()}' failed (Code: {exit_code_str}).", file=sys.stderr)
        if ' instal ' in last_command:
            print(f"YUPS: Did you mean 'install'?", file=sys.stderr)
        elif ' delete ' in last_command:
            print(f"YUPS: Did you mean 'remove' or 'autoremove'?", file=sys.stderr)
        print(f"YUPS: Try 'yups {last_command.strip()}'", file=sys.stderr)
        print(f"---", file=sys.stderr)

# --- 4. Export / Import Logic ---

def get_user_installed_packages(pm):
    """
    Executes PM-specific commands to list ONLY manually installed packages.
    Returns a list of strings.
    """
    cmd = []
    if pm == "dnf" or pm == "yum":
        # repoquery is cleaner than history userinstalled for machine reading
        cmd = ["dnf", "repoquery", "--userinstalled", "--queryformat", "%{NAME}"]
    elif pm == "apt" or pm == "apt-get":
        cmd = ["apt-mark", "showmanual"]
    elif pm == "pacman":
        cmd = ["pacman", "-Qqe"] # Query, Quiet, Explicit
    elif pm == "zypper":
        # Zypper is tricky. This searches for user-installed pattern/packages
        # Ideally we would parse xml, but for now we use a simple query
        print("YUPS_WARN: Zypper export is experimental (might include deps).")
        cmd = ["rpm", "-qa", "--qf", "%{NAME}\n"] # Fallback to all for now as explicit is hard in zypper cli
    else:
        return None

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        packages = [line.strip() for line in result.stdout.splitlines() if line.strip()]
        return packages
    except subprocess.CalledProcessError:
        return None
    except FileNotFoundError:
        return None

def handle_export(config):
    pm = config.get("pm")
    print(f"YUPS: Exporting explicitly installed packages from {pm}...")
    
    packages = get_user_installed_packages(pm)
    
    if not packages:
        print(f"YUPS_ERROR: Could not retrieve package list or list is empty.")
        return

    export_data = {
        "timestamp": datetime.datetime.now().isoformat(),
        "source_pm": pm,
        "source_distro": config.get("distro_id"),
        "count": len(packages),
        "packages": packages
    }
    
    filename = "yups-packages.json"
    try:
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2)
        print(f"âœ… Export successful!")
        print(f"ðŸ“¦ Found {len(packages)} packages.")
        print(f"ðŸ“„ Saved to: {os.path.abspath(filename)}")
    except Exception as e:
        print(f"YUPS_ERROR: Failed to save file: {e}")

def handle_import(filename, config):
    if not os.path.exists(filename):
        print(f"YUPS_ERROR: File '{filename}' not found.")
        return

    try:
        with open(filename, 'r') as f:
            data = json.load(f)
    except Exception as e:
        print(f"YUPS_ERROR: Invalid JSON file: {e}")
        return

    src_distro = data.get('source_distro', 'unknown')
    src_packages = data.get('packages', [])
    current_distro = config.get("distro_id")
    
    if not src_packages:
        print("YUPS_ERROR: No packages found in backup file.")
        return

    print(f"YUPS: Loaded backup from {src_distro} ({len(src_packages)} packages).")
    print(f"YUPS: Current system is {current_distro}.")

    package_list_str = ", ".join(src_packages)
    
    # --- AI MAGIC: Translate list to current system ---
    query = f"I want to install exactly these packages: {package_list_str}"
    
    # If distros match, we hint the AI to just verify names
    if src_distro == current_distro:
        print("YUPS: Same distro detected. Verifying package names...")
    else:
        print("YUPS: Different distro detected. Translating packages via Cloud...")

    # We use the existing AI loop to process this large intent
    process_ai_command(query, config)


# --- 5. Standard Command Handling ---

def handle_pm_command(action, packages, config):
    host_pm = config.get("pm")
    if host_pm == "unknown":
        print(f"YUPS_ERROR: Could not detect a known package manager.", file=sys.stderr)
        return
        
    action = PM_ALIASES.get(action, action)

    if action == "export":
        handle_export(config)
        return
    
    if action == "import":
        if not packages:
            print("YUPS_ERROR: Please specify a file to import (e.g., 'yups import yups-packages.json')")
            return
        handle_import(packages[0], config)
        return

    if action not in PM_COMMANDS:
        print(f"YUPS_ERROR: Unknown action '{action}'.", file=sys.stderr)
        return

    pm_config = PM_COMMANDS[action]
    command_template = pm_config["commands"].get(host_pm)
    
    if not command_template:
        print(f"YUPS_ERROR: Action '{action}' is not supported for '{host_pm}'.", file=sys.stderr)
        return
        
    package_string = " ".join(packages)

    if not pm_config["takes_packages"] and packages:
        print(f"YUPS_WARN: Action '{action}' does not take package arguments. Ignoring '{package_string}'.")
        package_string = ""
            
    if pm_config["takes_packages"] and not packages:
         print(f"YUPS_ERROR: Action '{action}' requires one or more package names.", file=sys.stderr)
         print(f"Example: yups {action} <package_name>")
         return

    final_command = command_template.format(packages=package_string)
    
    if os.geteuid() == 0 and final_command.startswith("sudo "):
        final_command = final_command.replace("sudo ", "", 1)

    log_async("action", f"user: 'yups {action} {package_string}', host_pm: {host_pm}, exec: '{final_command}'")
    
    print(f"YUPS: Detected {host_pm}. Running:")
    print(f"+ {final_command}\n")
    
    subprocess.run(final_command, shell=True, check=False)

# --- 6. API & Intelligence Layer ---

def fetch_llm_suggestion(query_string, config):
    endpoint = f"{YUPS_API_URL}/yups/v1/chat"
    
    headers = {
        "Content-Type": "application/json",
        YUPS_CLIENT_HEADER_NAME: YUPS_CLIENT_SECRET
    }
    
    payload = {
        "query": query_string,
        "config": config
    }

    try:
        response = requests.post(endpoint, json=payload, headers=headers, timeout=30) # Increased timeout for long lists
        
        if response.status_code == 429:
            return {"error": "You are sending requests too fast. Please wait."}
        
        if not response.ok:
            return {"error": f"Server Error ({response.status_code}): {response.text}"}
            
        data = response.json()
        return data.get("result", {"error": "Empty response from server"})

    except requests.exceptions.ConnectionError:
        return {"error": "Could not connect to YUPS Server. Check your internet connection."}
    except requests.exceptions.Timeout:
        return {"error": "YUPS Server timed out."}
    except Exception as e:
        return {"error": f"Client Error: {str(e)}"}

def process_ai_command(query_string, config):
    """Common logic for AI fallback and Import logic"""
    config['query'] = query_string
    config['is_root'] = (os.geteuid() == 0)

    print("â˜ï¸  Asking YUPS Cloud...")
    parsed = fetch_llm_suggestion(query_string, config)
    
    if parsed.get("error"):
        print(f"YUPS_ERROR: {parsed['error']}", file=sys.stderr)
    
    if parsed.get("explanation"):
        print(f"YUPS: {parsed['explanation']}")
        
    cmd = parsed.get("command")
    if cmd and cmd != "error":
        if config['is_root'] and cmd.strip().startswith("sudo "):
                cmd = cmd.strip().replace("sudo ", "", 1)

        print(f"Suggested command: {cmd}")
        try:
            confirm = input("Execute this command? [y/N] ").strip().lower()
            if confirm == 'y':
                subprocess.run(cmd, shell=True, check=False)
            else:
                print("Aborted.")
        except EOFError:
            pass
    else:
            if not parsed.get("error"):
                print("YUPS_ERROR: No command suggested.", file=sys.stderr)

    log_async("query", f"{query_string} -> {json.dumps(parsed)}")

# --- 7. Main Entry Point ---

def build_help_epilog():
    pm_help = "\nPackage Manager Commands:\n"
    for action, config in PM_COMMANDS.items():
        pm_help += f"  {action:<12} {config['help']}\n"
    
    # Manually add export/import help
    #pm_help += f"  {'export':<12} Save user-installed packages to JSON.\n"
    #pm_help += f"  {'import':<12} Install packages from a backup file.\n"

    alias_help = "\nCommand Aliases:\n"
    inverted_aliases = {}
    for alias, target in PM_ALIASES.items():
        inverted_aliases.setdefault(target, []).append(alias)
        
    for target, aliases in inverted_aliases.items():
        alias_help += f"  ({', '.join(aliases)}) -> {target}\n"
        
    final_epilog = (
        f"{pm_help}"
        f"{alias_help}\n"
        "If no specific command is given, 'yups' logs your query."
    )
    return final_epilog

def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == '--cnf-handle':
            args = sys.argv[2:]
            exit_code = handle_cnf(args)
            sys.exit(exit_code)
            
        if sys.argv[1] == '--ce-handle':
            args = sys.argv[2:]
            handle_ce(args)
            sys.exit(0)
    
    help_epilog = build_help_epilog()
    
    parser = argparse.ArgumentParser(
        description="YUPS: A Shell Helper and Package Manager wrapper.",
        epilog=help_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False
    )
    
    parser.add_argument('-h', '--help', action='store_true', help="show this help message and exit")
    parser.add_argument('--auto-config', action='store_true', help="Regenerate the system configuration cache.")
    
    args, remaining_args = parser.parse_known_args()
    
    if args.help:
        parser.print_help()
        sys.exit(0)
        
    if args.auto_config:
        run_auto_config()
        sys.exit(0)
        
    config = get_config_cache()
    
    if not remaining_args:
        parser.print_help()
        sys.exit(0)

    action = remaining_args[0].lower()
    packages = remaining_args[1:]
    
    # Check standard matrix or extras (export/import) or aliases
    if action in PM_COMMANDS or action in PM_ALIASES or action in EXTRA_COMMANDS:
        handle_pm_command(action, packages, config)
        
    else:
        # Fallback: Smart AI Action
        query_string = " ".join(remaining_args)
        process_ai_command(query_string, config)

if __name__ == "__main__":
    main()