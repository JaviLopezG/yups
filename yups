#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
YUPS - Core Executable (v7)

Changes:
- Refactored LLM interaction into 'fetch_llm_suggestion' function.
- Context now includes 'is_root' status for the LLM.
- Added safety guard to strip 'sudo' if running as root, even if LLM suggests it.
- Main loop is cleaner and decoupled from API specifics.
"""

import sys
import os
import platform
import datetime
import json
import shutil
import shlex
import subprocess
import argparse
import threading
from huggingface_hub import InferenceClient

# --- Configuration ---
YUPS_DIR = os.path.expanduser("~/.yups")
CONFIG_FILE = os.path.join(YUPS_DIR, "config.json")
LOG_DIR = os.path.join(YUPS_DIR, "logs")

LOG_FILES = {
    "cnf": os.path.join(LOG_DIR, "cnf.log"),
    "ce": os.path.join(LOG_DIR, "ce.log"),
    "query": os.path.join(LOG_DIR, "query.log"),
    "action": os.path.join(LOG_DIR, "action.log")
}

KNOWN_PMS = ["apt", "apt-get", "dnf", "yum", "pacman", "zypper"]

# --- PM Abstraction Matrix ---
PM_COMMANDS = {
    "install": {
        "help": "Install one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt install {packages}",
            "dnf": "sudo dnf install {packages}",
            "pacman": "sudo pacman -S {packages}",
            "zypper": "sudo zypper install {packages}",
        }
    },
    "remove": {
        "help": "Remove one or more packages.",
        "takes_packages": True,
        "commands": {
            "apt": "sudo apt remove {packages}",
            "dnf": "sudo dnf remove {packages}",
            "pacman": "sudo pacman -R {packages}",
            "zypper": "sudo zypper remove {packages}",
        }
    },
    "search": {
        "help": "Search for available packages.",
        "takes_packages": True,
        "commands": {
            "apt": "apt search {packages}",
            "dnf": "dnf search {packages}",
            "pacman": "pacman -Ss {packages}",
            "zypper": "zypper search {packages}",
        }
    },
    "autoremove": {
        "help": "Remove unused packages (cleanup).",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt autoremove",
            "dnf": "sudo dnf autoremove",
            "pacman": "sudo pacman -Rns $(pacman -Qdtq)",
            "zypper": "sudo zypper remove --clean-deps",
        }
    },
    "upgrade": {
        "help": "Upgrade all installed packages.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt upgrade",
            "dnf": "sudo dnf upgrade",
            "pacman": "sudo pacman -Syu",
            "zypper": "sudo zypper dup",
        }
    },
    "update": {
        "help": "Refresh package repository information.",
        "takes_packages": False,
        "commands": {
            "apt": "sudo apt update",
            "dnf": "sudo dnf check-update",
            "pacman": "sudo pacman -Sy",
            "zypper": "sudo zypper refresh",
        }
    },
    "provides": {
        "help": "Find which package provides a file or command.",
        "takes_packages": True,
        "commands": {
            "apt": "echo 'Use: apt-file search {packages} (requires apt-file)'",
            "dnf": "dnf provides {packages}",
            "pacman": "echo 'Use: pacman -F {packages} (requires pkgfile)'",
            "zypper": "zypper what-provides {packages}",
        }
    }
}
PM_ALIASES = {
    "add": "install",
    "+": "install",
    "-": "remove",
    "uninstall": "remove",
    "delete": "remove",
    "del": "remove",
    "available": "search",
    "find": "search",
    "clean": "autoremove",
    "upgrade-all": "upgrade",
    "upgradeall": "upgrade",
    "updaterepos": "update",
    "update-repos": "update",
    "what-provides": "provides",
    "where": "provides",
    "where-is": "provides",
    "whereis": "provides",
    "which": "provides",
}

# --- 1. Asynchronous Logging ---

def _log_to_file_sync(log_file, message):
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
        timestamp = datetime.datetime.now().isoformat()
        log_entry = f"{timestamp} | {message}\n"
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)
    except Exception:
        pass

def log_async(log_type, message):
    log_file = LOG_FILES.get(log_type)
    if not log_file:
        return
    log_thread = threading.Thread(
        target=_log_to_file_sync,
        args=(log_file, message),
        daemon=True
    )
    log_thread.start()

# --- 2. Config and Detection Logic ---

def detect_os_details():
    os_name = platform.system()
    distro_info = {
        "id": "unknown",
        "version_id": "unknown",
        "pretty_name": f"{os_name} (Unknown Distro)"
    }
    if os_name == "Linux" and os.path.exists("/etc/os-release"):
        try:
            with open("/etc/os-release", 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if '=' in line:
                        key, value = line.split('=', 1)
                        value = value.strip('"')
                        if key == "ID":
                            distro_info["id"] = value
                        elif key == "VERSION_ID":
                            distro_info["version_id"] = value
                        elif key == "PRETTY_NAME":
                            distro_info["pretty_name"] = value
        except Exception:
            pass
    return os_name, distro_info

def detect_pm():
    for pm_name in KNOWN_PMS:
        if shutil.which(pm_name):
            if pm_name == "apt-get":
                return "apt"
            if pm_name == "yum":
                if shutil.which("dnf"):
                    return "dnf"
                return "yum"
            return pm_name
    return "unknown"

def run_auto_config():
    os.makedirs(YUPS_DIR, exist_ok=True)
    os_name, distro_info = detect_os_details()
    pm_name = detect_pm()
    config = {
        "os": os_name,
        "pm": pm_name,
        "distro_id": distro_info.get("id"),
        "distro_version": distro_info.get("version_id"),
        "distro_pretty": distro_info.get("pretty_name"),
    }
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2)
        print(f"YUPS: Configuration saved to {CONFIG_FILE}")
        return config
    except Exception as e:
        print(f"YUPS_ERROR: Could not write config file: {e}", file=sys.stderr)
        return config

def get_config_cache():
    if not os.path.exists(CONFIG_FILE):
        return run_auto_config()
    try:
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return run_auto_config()

# --- 3. Handler Logic ---

def handle_cnf(args):
    log_async("cnf", f"raw_args: {args}")
    if not args:
        return 127
    
    failed_cmd = args[0]
    failed_args = args[1:]
    config = get_config_cache()
    host_pm = config.get("pm")

    if failed_cmd in KNOWN_PMS:
        if failed_cmd != host_pm and host_pm != "unknown":
            log_async("cnf", f"PM mismatch. Found: {failed_cmd}, Host: {host_pm}")
            print(f"YUPS: Command '{failed_cmd}' not found.", file=sys.stderr)
            print(f"YUPS: Maybe you meant '{host_pm}'?", file=sys.stderr)
            print(f"YUPS: Try 'yups {failed_cmd} {' '.join(failed_args)}'", file=sys.stderr)
            return 126
    
    default_handlers = [
        "/usr/libexec/packagekit-command-not-found",
        "/usr/libexec/pk-command-not-found",
        "/usr/lib/command-not-found",
        "/usr/share/command-not-found/command-not-found"
    ]
    for handler in default_handlers:
        if os.path.exists(handler):
            try:
                result = subprocess.run([handler] + args, check=False)
                return result.returncode
            except Exception:
                pass
                
    return 127

def handle_ce(args):
    if len(args) != 2:
        return
    
    exit_code_str, last_command = args[0], args[1]
    log_async("ce", f"exit_code: {exit_code_str}, cmd: '{last_command}'")
    
    command_with_padding = f" {last_command} "
    found_pm_in_cmd = False
    for pm in KNOWN_PMS:
        if f" {pm} " in command_with_padding:
            found_pm_in_cmd = True
            break

    if found_pm_in_cmd:
        print(f"---", file=sys.stderr)
        print(f"YUPS: The command '{last_command.strip()}' failed (Code: {exit_code_str}).", file=sys.stderr)
        if ' instal ' in last_command:
            print(f"YUPS: Did you mean 'install'?", file=sys.stderr)
        elif ' delete ' in last_command:
            print(f"YUPS: Did you mean 'remove' or 'autoremove'?", file=sys.stderr)
        print(f"YUPS: Try 'yups {last_command.strip()}'", file=sys.stderr)
        print(f"---", file=sys.stderr)

def handle_pm_command(action, packages, config):
    host_pm = config.get("pm")
    if host_pm == "unknown":
        print(f"YUPS_ERROR: Could not detect a known package manager.", file=sys.stderr)
        return
        
    action = PM_ALIASES.get(action, action)

    if action not in PM_COMMANDS:
        print(f"YUPS_ERROR: Unknown action '{action}'.", file=sys.stderr)
        return

    pm_config = PM_COMMANDS[action]
    command_template = pm_config["commands"].get(host_pm)
    
    if not command_template:
        print(f"YUPS_ERROR: Action '{action}' is not supported for '{host_pm}'.", file=sys.stderr)
        return
        
    package_string = " ".join(packages)

    if not pm_config["takes_packages"] and packages:
        print(f"YUPS_WARN: Action '{action}' does not take package arguments. Ignoring '{package_string}'.")
        package_string = ""
            
    if pm_config["takes_packages"] and not packages:
         print(f"YUPS_ERROR: Action '{action}' requires one or more package names.", file=sys.stderr)
         print(f"Example: yups {action} <package_name>")
         return

    final_command = command_template.format(packages=package_string)
    
    # Simple sudo removal if running as root
    if os.geteuid() == 0 and final_command.startswith("sudo "):
        final_command = final_command.replace("sudo ", "", 1)

    log_async("action", f"user: 'yups {action} {package_string}', host_pm: {host_pm}, exec: '{final_command}'")
    
    print(f"YUPS: Detected {host_pm}. Running:")
    print(f"+ {final_command}\n")
    
    subprocess.run(final_command, shell=True, check=False)

# --- 4. API & Intelligence Layer ---

def parse_llm_response(message):
    """Parses JSON content from the LLM response."""
    content = ""
    if hasattr(message, 'content'):
        content = message.content
    elif isinstance(message, str):
        content = message
    else:
        try:
            content = str(message)
        except Exception:
            return {"error": "Could not parse message content."}

    # Extract JSON code blocks
    if "```json" in content:
        content = content.split("```json")[1].split("```")[0].strip()
    elif "```" in content:
        content = content.split("```")[1].split("```")[0].strip()
    
    try:
        data = json.loads(content)
        return data
    except json.JSONDecodeError:
        return {"error": "LLM response was not valid JSON.", "raw": content}

def fetch_llm_suggestion(query_string, config):
    """
    Encapsulates all interaction with the AI backend.
    In the future, this function can be replaced to point to a custom API
    instead of calling Hugging Face directly.
    """
    token = os.environ.get("HF_TOKEN")
    if not token:
        return {"error": "Missing HF_TOKEN environment variable."}

    # Prepare context
    config_json = json.dumps(config)
    
    # Client Initialization
    client = InferenceClient(api_key=token)

    try:
        completion = client.chat.completions.create(
            model="google/gemma-3-27b-it:nebius",
            stream=False,
            temperature=0.1, 
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            'type': 'text',
                            'text': "You are an expert in linux package management. You must understand the user's intentionality and translate it to a package management command. "
                                    "You CAN return complex chained commands (e.g., 'zypper refresh && zypper update'). "
                                    "The context provides 'is_root' (boolean). "
                                    "If is_root is FALSE, ensure 'sudo' is applied to EACH subcommand that needs it (e.g., 'sudo apt update && sudo apt upgrade'). "
                                    "If is_root is TRUE, do NOT include 'sudo' in the commands. "
                                    "Return ONLY a JSON with fields: 'command' (string), 'explanation' (string), 'error' (string or null). "
                                    "Explain your election of packages with max. 10 words."
                                    "Context: " + config_json
                        }
                    ]
                }
            ],
        )
        return parse_llm_response(completion.choices[0].message)

    except Exception as e:
        return {"error": f"Failed to query LLM: {str(e)}"}

# --- 5. Main Argument Parsing & Routing ---

def build_help_epilog():
    pm_help = "\nPackage Manager Commands:\n"
    for action, config in PM_COMMANDS.items():
        pm_help += f"  {action:<12} {config['help']}\n"
        
    alias_help = "\nCommand Aliases:\n"
    inverted_aliases = {}
    for alias, target in PM_ALIASES.items():
        inverted_aliases.setdefault(target, []).append(alias)
        
    for target, aliases in inverted_aliases.items():
        alias_help += f"  ({', '.join(aliases)}) -> {target}\n"
        
    final_epilog = (
        f"{pm_help}"
        f"{alias_help}\n"
        "If no specific command is given, 'yups' logs your query."
    )
    return final_epilog

def main():
    if len(sys.argv) > 1:
        if sys.argv[1] == '--cnf-handle':
            args = sys.argv[2:]
            exit_code = handle_cnf(args)
            sys.exit(exit_code)
            
        if sys.argv[1] == '--ce-handle':
            args = sys.argv[2:]
            handle_ce(args)
            sys.exit(0)
    
    help_epilog = build_help_epilog()
    
    parser = argparse.ArgumentParser(
        description="YUPS: A Shell Helper and Package Manager wrapper.",
        epilog=help_epilog,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False
    )
    
    parser.add_argument('-h', '--help', action='store_true', help="show this help message and exit")
    parser.add_argument('--auto-config', action='store_true', help="Regenerate the system configuration cache.")
    
    args, remaining_args = parser.parse_known_args()
    
    if args.help:
        parser.print_help()
        sys.exit(0)
        
    if args.auto_config:
        run_auto_config()
        sys.exit(0)
        
    config = get_config_cache()
    
    if not remaining_args:
        parser.print_help()
        sys.exit(0)

    action = remaining_args[0].lower()
    packages = remaining_args[1:]
    
    if action in PM_COMMANDS or action in PM_ALIASES:
        handle_pm_command(action, packages, config)
        
    else:
        # --- Fallback: Smart action ---
        query_string = " ".join(remaining_args)
        
        # 1. Update Context with Query and Root status
        config['query'] = query_string
        config['is_root'] = (os.geteuid() == 0)

        # 2. Call the encapsulated Intelligence Layer
        parsed = fetch_llm_suggestion(query_string, config)
        
        # 3. Handle Errors/Feedback
        if parsed.get("error"):
            print(f"YUPS_ERROR: {parsed['error']}", file=sys.stderr)
        
        if parsed.get("explanation"):
            print(f"YUPS: {parsed['explanation']}")
            
        cmd = parsed.get("command")
        if cmd and cmd != "error":
            
            # --- Safety Guard: Redundant Sudo Strip ---
            # Even if LLM is smart, we explicitly strip sudo if we are root.
            # Only strips if it's the very first word (handling "sudo apt ...").
            # For complex chains like "sudo apt update && sudo apt upgrade",
            # replacing just the first one is tricky without parsing.
            # However, prompt instruction tells LLM to not add it if is_root is True.
            # This is a fallback for the simplest/most common case.
            if config['is_root'] and cmd.strip().startswith("sudo "):
                 cmd = cmd.strip().replace("sudo ", "", 1)

            print(f"Suggested command: {cmd}")
            try:
                confirm = input("Execute this command? [y/N] ").strip().lower()
                if confirm == 'y':
                    subprocess.run(cmd, shell=True, check=False)
                else:
                    print("Aborted.")
            except EOFError:
                pass
        else:
             if not parsed.get("error"):
                 print("YUPS_ERROR: No command suggested.", file=sys.stderr)

        log_async("query", f"{query_string} -> {json.dumps(parsed)}")

if __name__ == "__main__":
    main()